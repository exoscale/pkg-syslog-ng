From e0e45b9b6d636ffdbcfbd9f3d1e6c36b34e4bc52 Mon Sep 17 00:00:00 2001
From: Balazs Scheidler <balazs.scheidler@balabit.com>
Date: Sun, 22 Nov 2015 18:38:57 +0100
Subject: [PATCH] nvtable: use memmove() instead of memcpy()

In case the caller supplies a pointer within the nvtable space (e.g. names
or values retrieved from the nvtable itself), we might be copying overlapping
memory areas, handle this by using memmove instead of memcpy when
we copy names/values within the nvtable.

Spotted by valgrind.

Signed-off-by: Balazs Scheidler <balazs.scheidler@balabit.com>
---
 lib/nvtable.c | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

Index: syslog-ng-3.6.4/lib/nvtable.c
===================================================================
--- syslog-ng-3.6.4.orig/lib/nvtable.c
+++ syslog-ng-3.6.4/lib/nvtable.c
@@ -401,7 +401,7 @@ nv_table_add_value(NVTable *self, NVHand
           dst = entry->vdirect.data + entry->name_len + 1;
 
           entry->vdirect.value_len = value_len;
-          memcpy(dst, value, value_len);
+          memmove(dst, value, value_len);
           dst[value_len] = 0;
         }
       else
@@ -410,8 +410,8 @@ nv_table_add_value(NVTable *self, NVHand
           entry->indirect = 0;
           entry->vdirect.value_len = value_len;
           entry->name_len = name_len;
-          memcpy(entry->vdirect.data, name, name_len + 1);
-          memcpy(entry->vdirect.data + name_len + 1, value, value_len);
+          memmove(entry->vdirect.data, name, name_len + 1);
+          memmove(entry->vdirect.data + name_len + 1, value, value_len);
           entry->vdirect.data[entry->name_len + 1 + value_len] = 0;
         }
       return TRUE;
@@ -435,11 +435,11 @@ nv_table_add_value(NVTable *self, NVHand
     {
       /* we only store the name for non-builtin values */
       entry->name_len = name_len;
-      memcpy(entry->vdirect.data, name, name_len + 1);
+      memmove(entry->vdirect.data, name, name_len + 1);
     }
   else
     entry->name_len = 0;
-  memcpy(entry->vdirect.data + entry->name_len + 1, value, value_len);
+  memmove(entry->vdirect.data + entry->name_len + 1, value, value_len);
   entry->vdirect.data[entry->name_len + 1 + value_len] = 0;
 
   nv_table_set_table_entry(self, handle, ofs, dyn_slot);
@@ -510,7 +510,7 @@ nv_table_add_value_indirect(NVTable *sel
           if (handle >= self->num_static_entries)
             {
               entry->name_len = name_len;
-              memcpy(entry->vindirect.name, name, name_len + 1);
+              memmove(entry->vindirect.name, name, name_len + 1);
             }
           else
             {
@@ -540,7 +540,7 @@ nv_table_add_value_indirect(NVTable *sel
   if (handle >= self->num_static_entries)
     {
       entry->name_len = name_len;
-      memcpy(entry->vindirect.name, name, name_len + 1);
+      memmove(entry->vindirect.name, name, name_len + 1);
     }
   else
     entry->name_len = 0;
