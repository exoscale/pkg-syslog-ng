From e0e45b9b6d636ffdbcfbd9f3d1e6c36b34e4bc52 Mon Sep 17 00:00:00 2001
From: Balazs Scheidler <balazs.scheidler@balabit.com>
Date: Sun, 22 Nov 2015 18:38:57 +0100
Subject: [PATCH] nvtable: use memmove() instead of memcpy()

In case the caller supplies a pointer within the nvtable space (e.g. names
or values retrieved from the nvtable itself), we might be copying overlapping
memory areas, handle this by using memmove instead of memcpy when
we copy names/values within the nvtable.

Spotted by valgrind.

Signed-off-by: Balazs Scheidler <balazs.scheidler@balabit.com>
---
 lib/nvtable.c | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/lib/nvtable.c b/lib/nvtable.c
index cf6a6ff3ec4a..9c05736386cf 100644
--- a/lib/nvtable.c
+++ b/lib/nvtable.c
@@ -404,7 +404,7 @@ nv_table_add_value(NVTable *self, NVHandle handle, const gchar *name, gsize name
           dst = entry->vdirect.data + entry->name_len + 1;
 
           entry->vdirect.value_len = value_len;
-          memcpy(dst, value, value_len);
+          memmove(dst, value, value_len);
           dst[value_len] = 0;
         }
       else
@@ -413,8 +413,8 @@ nv_table_add_value(NVTable *self, NVHandle handle, const gchar *name, gsize name
           entry->indirect = 0;
           entry->vdirect.value_len = value_len;
           entry->name_len = name_len;
-          memcpy(entry->vdirect.data, name, name_len + 1);
-          memcpy(entry->vdirect.data + name_len + 1, value, value_len);
+          memmove(entry->vdirect.data, name, name_len + 1);
+          memmove(entry->vdirect.data + name_len + 1, value, value_len);
           entry->vdirect.data[entry->name_len + 1 + value_len] = 0;
         }
       return TRUE;
@@ -438,11 +438,11 @@ nv_table_add_value(NVTable *self, NVHandle handle, const gchar *name, gsize name
     {
       /* we only store the name for non-builtin values */
       entry->name_len = name_len;
-      memcpy(entry->vdirect.data, name, name_len + 1);
+      memmove(entry->vdirect.data, name, name_len + 1);
     }
   else
     entry->name_len = 0;
-  memcpy(entry->vdirect.data + entry->name_len + 1, value, value_len);
+  memmove(entry->vdirect.data + entry->name_len + 1, value, value_len);
   entry->vdirect.data[entry->name_len + 1 + value_len] = 0;
 
   nv_table_set_table_entry(self, handle, ofs, dyn_slot);
@@ -513,7 +513,7 @@ nv_table_add_value_indirect(NVTable *self, NVHandle handle, const gchar *name, g
           if (handle >= self->num_static_entries)
             {
               entry->name_len = name_len;
-              memcpy(entry->vindirect.name, name, name_len + 1);
+              memmove(entry->vindirect.name, name, name_len + 1);
             }
           else
             {
@@ -543,7 +543,7 @@ nv_table_add_value_indirect(NVTable *self, NVHandle handle, const gchar *name, g
   if (handle >= self->num_static_entries)
     {
       entry->name_len = name_len;
-      memcpy(entry->vindirect.name, name, name_len + 1);
+      memmove(entry->vindirect.name, name, name_len + 1);
     }
   else
     entry->name_len = 0;
-- 
2.11.0

